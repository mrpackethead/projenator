"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudExecutable = void 0;
const fs_1 = require("fs");
const cxapi = require("@aws-cdk/cx-api");
const region_info_1 = require("@aws-cdk/region-info");
const contextproviders = require("../../context-providers");
const logging_1 = require("../../logging");
const cloud_assembly_1 = require("./cloud-assembly");
/**
 * Represent the Cloud Executable and the synthesis we can do on it
 */
class CloudExecutable {
    constructor(props) {
        this.props = props;
    }
    /**
     * Return whether there is an app command from the configuration
     */
    get hasApp() {
        return !!this.props.configuration.settings.get(['app']);
    }
    /**
     * Synthesize a set of stacks.
     *
     * @param cacheCloudAssembly whether to cache the Cloud Assembly after it has been first synthesized.
     *   This is 'true' by default, and only set to 'false' for 'cdk watch',
     *   which needs to re-synthesize the Assembly each time it detects a change to the project files
     */
    async synthesize(cacheCloudAssembly = true) {
        if (!this._cloudAssembly || !cacheCloudAssembly) {
            this._cloudAssembly = await this.doSynthesize();
        }
        return this._cloudAssembly;
    }
    async doSynthesize() {
        const trackVersions = this.props.configuration.settings.get(['versionReporting']);
        // We may need to run the cloud executable multiple times in order to satisfy all missing context
        // (When the executable runs, it will tell us about context it wants to use
        // but it missing. We'll then look up the context and run the executable again, and
        // again, until it doesn't complain anymore or we've stopped making progress).
        let previouslyMissingKeys;
        while (true) {
            const assembly = await this.props.synthesizer(this.props.sdkProvider, this.props.configuration);
            if (assembly.manifest.missing && assembly.manifest.missing.length > 0) {
                const missingKeys = missingContextKeys(assembly.manifest.missing);
                if (!this.canLookup) {
                    throw new Error('Context lookups have been disabled. '
                        + 'Make sure all necessary context is already in \'cdk.context.json\' by running \'cdk synth\' on a machine with sufficient AWS credentials and committing the result. '
                        + `Missing context keys: '${Array.from(missingKeys).join(', ')}'`);
                }
                let tryLookup = true;
                if (previouslyMissingKeys && setsEqual(missingKeys, previouslyMissingKeys)) {
                    logging_1.debug('Not making progress trying to resolve environmental context. Giving up.');
                    tryLookup = false;
                }
                previouslyMissingKeys = missingKeys;
                if (tryLookup) {
                    logging_1.debug('Some context information is missing. Fetching...');
                    await contextproviders.provideContextValues(assembly.manifest.missing, this.props.configuration.context, this.props.sdkProvider);
                    // Cache the new context to disk
                    await this.props.configuration.saveContext();
                    // Execute again
                    continue;
                }
            }
            if (trackVersions) {
                // @deprecated(v2): remove this 'if' block and all code referenced by it.
                // This should honestly not be done here. The framework
                // should (and will, shortly) synthesize this information directly into
                // the template. However, in order to support old framework versions
                // that don't synthesize this info yet, we can only remove this code
                // once we break backwards compatibility.
                await this.addMetadataResource(assembly);
            }
            return new cloud_assembly_1.CloudAssembly(assembly);
        }
    }
    /**
     * Modify the templates in the assembly in-place to add metadata resource declarations
     */
    async addMetadataResource(rootAssembly) {
        if (!rootAssembly.runtime) {
            return;
        }
        const modules = formatModules(rootAssembly.runtime);
        await processAssembly(rootAssembly);
        async function processAssembly(assembly) {
            for (const stack of assembly.stacks) {
                await processStack(stack);
            }
            for (const nested of assembly.nestedAssemblies) {
                await processAssembly(nested.nestedAssembly);
            }
        }
        async function processStack(stack) {
            const resourcePresent = stack.environment.region === cxapi.UNKNOWN_REGION
                || region_info_1.RegionInfo.get(stack.environment.region).cdkMetadataResourceAvailable;
            if (!resourcePresent) {
                return;
            }
            if (!stack.template.Resources) {
                stack.template.Resources = {};
            }
            if (stack.template.Resources.CDKMetadata) {
                // Already added by framework, this is expected.
                return;
            }
            stack.template.Resources.CDKMetadata = {
                Type: 'AWS::CDK::Metadata',
                Properties: {
                    Modules: modules,
                },
            };
            if (stack.environment.region === cxapi.UNKNOWN_REGION) {
                stack.template.Conditions = stack.template.Conditions || {};
                const condName = 'CDKMetadataAvailable';
                if (!stack.template.Conditions[condName]) {
                    stack.template.Conditions[condName] = _makeCdkMetadataAvailableCondition();
                    stack.template.Resources.CDKMetadata.Condition = condName;
                }
                else {
                    logging_1.warning(`The stack ${stack.id} already includes a ${condName} condition`);
                }
            }
            // The template has changed in-memory, but the file on disk remains unchanged so far.
            // The CLI *might* later on deploy the in-memory version (if it's <50kB) or use the
            // on-disk version (if it's >50kB).
            //
            // Be sure to flush the changes we just made back to disk. The on-disk format is always
            // JSON.
            await fs_1.promises.writeFile(stack.templateFullPath, JSON.stringify(stack.template, undefined, 2), { encoding: 'utf-8' });
        }
    }
    get canLookup() {
        var _a;
        return !!((_a = this.props.configuration.settings.get(['lookups'])) !== null && _a !== void 0 ? _a : true);
    }
}
exports.CloudExecutable = CloudExecutable;
/**
 * Return all keys of missing context items
 */
function missingContextKeys(missing) {
    return new Set((missing || []).map(m => m.key));
}
function setsEqual(a, b) {
    if (a.size !== b.size) {
        return false;
    }
    for (const x of a) {
        if (!b.has(x)) {
            return false;
        }
    }
    return true;
}
function _makeCdkMetadataAvailableCondition() {
    return _fnOr(region_info_1.RegionInfo.regions
        .filter(ri => ri.cdkMetadataResourceAvailable)
        .map(ri => ({ 'Fn::Equals': [{ Ref: 'AWS::Region' }, ri.name] })));
}
/**
 * This takes a bunch of operands and crafts an `Fn::Or` for those. Funny thing is `Fn::Or` requires
 * at least 2 operands and at most 10 operands, so we have to... do this.
 */
function _fnOr(operands) {
    if (operands.length === 0) {
        throw new Error('Cannot build `Fn::Or` with zero operands!');
    }
    if (operands.length === 1) {
        return operands[0];
    }
    if (operands.length <= 10) {
        return { 'Fn::Or': operands };
    }
    return _fnOr(_inGroupsOf(operands, 10).map(group => _fnOr(group)));
}
function _inGroupsOf(array, maxGroup) {
    const result = new Array();
    for (let i = 0; i < array.length; i += maxGroup) {
        result.push(array.slice(i, i + maxGroup));
    }
    return result;
}
function formatModules(runtime) {
    const modules = new Array();
    // inject toolkit version to list of modules
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const toolkitVersion = require('../../../package.json').version;
    modules.push(`aws-cdk=${toolkitVersion}`);
    for (const key of Object.keys(runtime.libraries).sort()) {
        modules.push(`${key}=${runtime.libraries[key]}`);
    }
    return modules.join(',');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWQtZXhlY3V0YWJsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNsb3VkLWV4ZWN1dGFibGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsMkJBQW9DO0FBQ3BDLHlDQUF5QztBQUN6QyxzREFBa0Q7QUFDbEQsNERBQTREO0FBQzVELDJDQUErQztBQUcvQyxxREFBaUQ7QUF3QmpEOztHQUVHO0FBQ0gsTUFBYSxlQUFlO0lBRzFCLFlBQTZCLEtBQTJCO1FBQTNCLFVBQUssR0FBTCxLQUFLLENBQXNCO0lBQ3hELENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsTUFBTTtRQUNmLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxLQUFLLENBQUMsVUFBVSxDQUFDLHFCQUE4QixJQUFJO1FBQ3hELElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxJQUFJLENBQUMsa0JBQWtCLEVBQUU7WUFDL0MsSUFBSSxDQUFDLGNBQWMsR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztTQUNqRDtRQUNELE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQztJQUM3QixDQUFDO0lBRU8sS0FBSyxDQUFDLFlBQVk7UUFDeEIsTUFBTSxhQUFhLEdBQVksSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQztRQUUzRixpR0FBaUc7UUFDakcsMkVBQTJFO1FBQzNFLG1GQUFtRjtRQUNuRiw4RUFBOEU7UUFDOUUsSUFBSSxxQkFBOEMsQ0FBQztRQUNuRCxPQUFPLElBQUksRUFBRTtZQUNYLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtB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SUFFMUMsS0FBSyxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtRQUN2RCxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQ2xEO0lBQ0QsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzNCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBSZWdpb25JbmZvIH0gZnJvbSAnQGF3cy1jZGsvcmVnaW9uLWluZm8nO1xuaW1wb3J0ICogYXMgY29udGV4dHByb3ZpZGVycyBmcm9tICcuLi8uLi9jb250ZXh0LXByb3ZpZGVycyc7XG5pbXBvcnQgeyBkZWJ1Zywgd2FybmluZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgQ29uZmlndXJhdGlvbiB9IGZyb20gJy4uLy4uL3NldHRpbmdzJztcbmltcG9ydCB7IFNka1Byb3ZpZGVyIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgQ2xvdWRBc3NlbWJseSB9IGZyb20gJy4vY2xvdWQtYXNzZW1ibHknO1xuXG4vKipcbiAqIEByZXR1cm5zIG91dHB1dCBkaXJlY3RvcnlcbiAqL1xudHlwZSBTeW50aGVzaXplciA9IChhd3M6IFNka1Byb3ZpZGVyLCBjb25maWc6IENvbmZpZ3VyYXRpb24pID0+IFByb21pc2U8Y3hhcGkuQ2xvdWRBc3NlbWJseT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xvdWRFeGVjdXRhYmxlUHJvcHMge1xuICAvKipcbiAgICogQXBwbGljYXRpb24gY29uZmlndXJhdGlvbiAoc2V0dGluZ3MgYW5kIGNvbnRleHQpXG4gICAqL1xuICBjb25maWd1cmF0aW9uOiBDb25maWd1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBBV1Mgb2JqZWN0ICh1c2VkIGJ5IHN5bnRoZXNpemVyIGFuZCBjb250ZXh0cHJvdmlkZXIpXG4gICAqL1xuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXI7XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGludm9rZWQgdG8gc3ludGhlc2l6ZSB0aGUgYWN0dWFsIHN0YWNrc1xuICAgKi9cbiAgc3ludGhlc2l6ZXI6IFN5bnRoZXNpemVyO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCB0aGUgQ2xvdWQgRXhlY3V0YWJsZSBhbmQgdGhlIHN5bnRoZXNpcyB3ZSBjYW4gZG8gb24gaXRcbiAqL1xuZXhwb3J0IGNsYXNzIENsb3VkRXhlY3V0YWJsZSB7XG4gIHByaXZhdGUgX2Nsb3VkQXNzZW1ibHk/OiBDbG91ZEFzc2VtYmx5O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvcHM6IENsb3VkRXhlY3V0YWJsZVByb3BzKSB7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlcmUgaXMgYW4gYXBwIGNvbW1hbmQgZnJvbSB0aGUgY29uZmlndXJhdGlvblxuICAgKi9cbiAgcHVibGljIGdldCBoYXNBcHAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5wcm9wcy5jb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ2FwcCddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aGVzaXplIGEgc2V0IG9mIHN0YWNrcy5cbiAgICpcbiAgICogQHBhcmFtIGNhY2hlQ2xvdWRBc3NlbWJseSB3aGV0aGVyIHRvIGNhY2hlIHRoZSBDbG91ZCBBc3NlbWJseSBhZnRlciBpdCBoYXMgYmVlbiBmaXJzdCBzeW50aGVzaXplZC5cbiAgICogICBUaGlzIGlzICd0cnVlJyBieSBkZWZhdWx0LCBhbmQgb25seSBzZXQgdG8gJ2ZhbHNlJyBmb3IgJ2NkayB3YXRjaCcsXG4gICAqICAgd2hpY2ggbmVlZHMgdG8gcmUtc3ludGhlc2l6ZSB0aGUgQXNzZW1ibHkgZWFjaCB0aW1lIGl0IGRldGVjdHMgYSBjaGFuZ2UgdG8gdGhlIHByb2plY3QgZmlsZXNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBzeW50aGVzaXplKGNhY2hlQ2xvdWRBc3NlbWJseTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPENsb3VkQXNzZW1ibHk+IHtcbiAgICBpZiAoIXRoaXMuX2Nsb3VkQXNzZW1ibHkgfHwgIWNhY2hlQ2xvdWRBc3NlbWJseSkge1xuICAgICAgdGhpcy5fY2xvdWRBc3NlbWJseSA9IGF3YWl0IHRoaXMuZG9TeW50aGVzaXplKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbG91ZEFzc2VtYmx5O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBkb1N5bnRoZXNpemUoKTogUHJvbWlzZTxDbG91ZEFzc2VtYmx5PiB7XG4gICAgY29uc3QgdHJhY2tWZXJzaW9uczogYm9vbGVhbiA9IHRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWyd2ZXJzaW9uUmVwb3J0aW5nJ10pO1xuXG4gICAgLy8gV2UgbWF5IG5lZWQgdG8gcnVuIHRoZSBjbG91ZCBleGVjdXRhYmxlIG11bHRpcGxlIHRpbWVzIGluIG9yZGVyIHRvIHNhdGlzZnkgYWxsIG1pc3NpbmcgY29udGV4dFxuICAgIC8vIChXaGVuIHRoZSBleGVjdXRhYmxlIHJ1bnMsIGl0IHdpbGwgdGVsbCB1cyBhYm91dCBjb250ZXh0IGl0IHdhbnRzIHRvIHVzZVxuICAgIC8vIGJ1dCBpdCBtaXNzaW5nLiBXZSdsbCB0aGVuIGxvb2sgdXAgdGhlIGNvbnRleHQgYW5kIHJ1biB0aGUgZXhlY3V0YWJsZSBhZ2FpbiwgYW5kXG4gICAgLy8gYWdhaW4sIHVudGlsIGl0IGRvZXNuJ3QgY29tcGxhaW4gYW55bW9yZSBvciB3ZSd2ZSBzdG9wcGVkIG1ha2luZyBwcm9ncmVzcykuXG4gICAgbGV0IHByZXZpb3VzbHlNaXNzaW5nS2V5czogU2V0PHN0cmluZz4gfCB1bmRlZmluZWQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGFzc2VtYmx5ID0gYXdhaXQgdGhpcy5wcm9wcy5zeW50aGVzaXplcih0aGlzLnByb3BzLnNka1Byb3ZpZGVyLCB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBpZiAoYXNzZW1ibHkubWFuaWZlc3QubWlzc2luZyAmJiBhc3NlbWJseS5tYW5pZmVzdC5taXNzaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ0tleXMgPSBtaXNzaW5nQ29udGV4dEtleXMoYXNzZW1ibHkubWFuaWZlc3QubWlzc2luZyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNhbkxvb2t1cCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDb250ZXh0IGxvb2t1cHMgaGF2ZSBiZWVuIGRpc2FibGVkLiAnXG4gICAgICAgICAgICArICdNYWtlIHN1cmUgYWxsIG5lY2Vzc2FyeSBjb250ZXh0IGlzIGFscmVhZHkgaW4gXFwnY2RrLmNvbnRleHQuanNvblxcJyBieSBydW5uaW5nIFxcJ2NkayBzeW50aFxcJyBvbiBhIG1hY2hpbmUgd2l0aCBzdWZmaWNpZW50IEFXUyBjcmVkZW50aWFscyBhbmQgY29tbWl0dGluZyB0aGUgcmVzdWx0LiAnXG4gICAgICAgICAgICArIGBNaXNzaW5nIGNvbnRleHQga2V5czogJyR7QXJyYXkuZnJvbShtaXNzaW5nS2V5cykuam9pbignLCAnKX0nYCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdHJ5TG9va3VwID0gdHJ1ZTtcbiAgICAgICAgaWYgKHByZXZpb3VzbHlNaXNzaW5nS2V5cyAmJiBzZXRzRXF1YWwobWlzc2luZ0tleXMsIHByZXZpb3VzbHlNaXNzaW5nS2V5cykpIHtcbiAgICAgICAgICBkZWJ1ZygnTm90IG1ha2luZyBwcm9ncmVzcyB0cnlpbmcgdG8gcmVzb2x2ZSBlbnZpcm9ubWVudGFsIGNvbnRleHQuIEdpdmluZyB1cC4nKTtcbiAgICAgICAgICB0cnlMb29rdXAgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzbHlNaXNzaW5nS2V5cyA9IG1pc3NpbmdLZXlzO1xuXG4gICAgICAgIGlmICh0cnlMb29rdXApIHtcbiAgICAgICAgICBkZWJ1ZygnU29tZSBjb250ZXh0IGluZm9ybWF0aW9uIGlzIG1pc3NpbmcuIEZldGNoaW5nLi4uJyk7XG5cbiAgICAgICAgICBhd2FpdCBjb250ZXh0cHJvdmlkZXJzLnByb3ZpZGVDb250ZXh0VmFsdWVzKFxuICAgICAgICAgICAgYXNzZW1ibHkubWFuaWZlc3QubWlzc2luZyxcbiAgICAgICAgICAgIHRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5jb250ZXh0LFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5zZGtQcm92aWRlcik7XG5cbiAgICAgICAgICAvLyBDYWNoZSB0aGUgbmV3IGNvbnRleHQgdG8gZGlza1xuICAgICAgICAgIGF3YWl0IHRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5zYXZlQ29udGV4dCgpO1xuXG4gICAgICAgICAgLy8gRXhlY3V0ZSBhZ2FpblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFja1ZlcnNpb25zKSB7XG4gICAgICAgIC8vIEBkZXByZWNhdGVkKHYyKTogcmVtb3ZlIHRoaXMgJ2lmJyBibG9jayBhbmQgYWxsIGNvZGUgcmVmZXJlbmNlZCBieSBpdC5cbiAgICAgICAgLy8gVGhpcyBzaG91bGQgaG9uZXN0bHkgbm90IGJlIGRvbmUgaGVyZS4gVGhlIGZyYW1ld29ya1xuICAgICAgICAvLyBzaG91bGQgKGFuZCB3aWxsLCBzaG9ydGx5KSBzeW50aGVzaXplIHRoaXMgaW5mb3JtYXRpb24gZGlyZWN0bHkgaW50b1xuICAgICAgICAvLyB0aGUgdGVtcGxhdGUuIEhvd2V2ZXIsIGluIG9yZGVyIHRvIHN1cHBvcnQgb2xkIGZyYW1ld29yayB2ZXJzaW9uc1xuICAgICAgICAvLyB0aGF0IGRvbid0IHN5bnRoZXNpemUgdGhpcyBpbmZvIHlldCwgd2UgY2FuIG9ubHkgcmVtb3ZlIHRoaXMgY29kZVxuICAgICAgICAvLyBvbmNlIHdlIGJyZWFrIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBhd2FpdCB0aGlzLmFkZE1ldGFkYXRhUmVzb3VyY2UoYXNzZW1ibHkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IENsb3VkQXNzZW1ibHkoYXNzZW1ibHkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIHRlbXBsYXRlcyBpbiB0aGUgYXNzZW1ibHkgaW4tcGxhY2UgdG8gYWRkIG1ldGFkYXRhIHJlc291cmNlIGRlY2xhcmF0aW9uc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBhZGRNZXRhZGF0YVJlc291cmNlKHJvb3RBc3NlbWJseTogY3hhcGkuQ2xvdWRBc3NlbWJseSkge1xuICAgIGlmICghcm9vdEFzc2VtYmx5LnJ1bnRpbWUpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBtb2R1bGVzID0gZm9ybWF0TW9kdWxlcyhyb290QXNzZW1ibHkucnVudGltZSk7XG4gICAgYXdhaXQgcHJvY2Vzc0Fzc2VtYmx5KHJvb3RBc3NlbWJseSk7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQXNzZW1ibHkoYXNzZW1ibHk6IGN4YXBpLkNsb3VkQXNzZW1ibHkpIHtcbiAgICAgIGZvciAoY29uc3Qgc3RhY2sgb2YgYXNzZW1ibHkuc3RhY2tzKSB7XG4gICAgICAgIGF3YWl0IHByb2Nlc3NTdGFjayhzdGFjayk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG5lc3RlZCBvZiBhc3NlbWJseS5uZXN0ZWRBc3NlbWJsaWVzKSB7XG4gICAgICAgIGF3YWl0IHByb2Nlc3NBc3NlbWJseShuZXN0ZWQubmVzdGVkQXNzZW1ibHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTdGFjayhzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0KSB7XG4gICAgICBjb25zdCByZXNvdXJjZVByZXNlbnQgPSBzdGFjay5lbnZpcm9ubWVudC5yZWdpb24gPT09IGN4YXBpLlVOS05PV05fUkVHSU9OXG4gICAgICAgIHx8IFJlZ2lvbkluZm8uZ2V0KHN0YWNrLmVudmlyb25tZW50LnJlZ2lvbikuY2RrTWV0YWRhdGFSZXNvdXJjZUF2YWlsYWJsZTtcbiAgICAgIGlmICghcmVzb3VyY2VQcmVzZW50KSB7IHJldHVybjsgfVxuXG4gICAgICBpZiAoIXN0YWNrLnRlbXBsYXRlLlJlc291cmNlcykge1xuICAgICAgICBzdGFjay50ZW1wbGF0ZS5SZXNvdXJjZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFjay50ZW1wbGF0ZS5SZXNvdXJjZXMuQ0RLTWV0YWRhdGEpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBhZGRlZCBieSBmcmFtZXdvcmssIHRoaXMgaXMgZXhwZWN0ZWQuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3RhY2sudGVtcGxhdGUuUmVzb3VyY2VzLkNES01ldGFkYXRhID0ge1xuICAgICAgICBUeXBlOiAnQVdTOjpDREs6Ok1ldGFkYXRhJyxcbiAgICAgICAgUHJvcGVydGllczoge1xuICAgICAgICAgIE1vZHVsZXM6IG1vZHVsZXMsXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBpZiAoc3RhY2suZW52aXJvbm1lbnQucmVnaW9uID09PSBjeGFwaS5VTktOT1dOX1JFR0lPTikge1xuICAgICAgICBzdGFjay50ZW1wbGF0ZS5Db25kaXRpb25zID0gc3RhY2sudGVtcGxhdGUuQ29uZGl0aW9ucyB8fCB7fTtcbiAgICAgICAgY29uc3QgY29uZE5hbWUgPSAnQ0RLTWV0YWRhdGFBdmFpbGFibGUnO1xuICAgICAgICBpZiAoIXN0YWNrLnRlbXBsYXRlLkNvbmRpdGlvbnNbY29uZE5hbWVdKSB7XG4gICAgICAgICAgc3RhY2sudGVtcGxhdGUuQ29uZGl0aW9uc1tjb25kTmFtZV0gPSBfbWFrZUNka01ldGFkYXRhQXZhaWxhYmxlQ29uZGl0aW9uKCk7XG4gICAgICAgICAgc3RhY2sudGVtcGxhdGUuUmVzb3VyY2VzLkNES01ldGFkYXRhLkNvbmRpdGlvbiA9IGNvbmROYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5pbmcoYFRoZSBzdGFjayAke3N0YWNrLmlkfSBhbHJlYWR5IGluY2x1ZGVzIGEgJHtjb25kTmFtZX0gY29uZGl0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHRlbXBsYXRlIGhhcyBjaGFuZ2VkIGluLW1lbW9yeSwgYnV0IHRoZSBmaWxlIG9uIGRpc2sgcmVtYWlucyB1bmNoYW5nZWQgc28gZmFyLlxuICAgICAgLy8gVGhlIENMSSAqbWlnaHQqIGxhdGVyIG9uIGRlcGxveSB0aGUgaW4tbWVtb3J5IHZlcnNpb24gKGlmIGl0J3MgPDUwa0IpIG9yIHVzZSB0aGVcbiAgICAgIC8vIG9uLWRpc2sgdmVyc2lvbiAoaWYgaXQncyA+NTBrQikuXG4gICAgICAvL1xuICAgICAgLy8gQmUgc3VyZSB0byBmbHVzaCB0aGUgY2hhbmdlcyB3ZSBqdXN0IG1hZGUgYmFjayB0byBkaXNrLiBUaGUgb24tZGlzayBmb3JtYXQgaXMgYWx3YXlzXG4gICAgICAvLyBKU09OLlxuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHN0YWNrLnRlbXBsYXRlRnVsbFBhdGgsIEpTT04uc3RyaW5naWZ5KHN0YWNrLnRlbXBsYXRlLCB1bmRlZmluZWQsIDIpLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGNhbkxvb2t1cCgpIHtcbiAgICByZXR1cm4gISEodGhpcy5wcm9wcy5jb25maWd1cmF0aW9uLnNldHRpbmdzLmdldChbJ2xvb2t1cHMnXSkgPz8gdHJ1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gYWxsIGtleXMgb2YgbWlzc2luZyBjb250ZXh0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIG1pc3NpbmdDb250ZXh0S2V5cyhtaXNzaW5nPzogY3hhcGkuTWlzc2luZ0NvbnRleHRbXSk6IFNldDxzdHJpbmc+IHtcbiAgcmV0dXJuIG5ldyBTZXQoKG1pc3NpbmcgfHwgW10pLm1hcChtID0+IG0ua2V5KSk7XG59XG5cbmZ1bmN0aW9uIHNldHNFcXVhbDxBPihhOiBTZXQ8QT4sIGI6IFNldDxBPikge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGZvciAoY29uc3QgeCBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyh4KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX21ha2VDZGtNZXRhZGF0YUF2YWlsYWJsZUNvbmRpdGlvbigpIHtcbiAgcmV0dXJuIF9mbk9yKFJlZ2lvbkluZm8ucmVnaW9uc1xuICAgIC5maWx0ZXIocmkgPT4gcmkuY2RrTWV0YWRhdGFSZXNvdXJjZUF2YWlsYWJsZSlcbiAgICAubWFwKHJpID0+ICh7ICdGbjo6RXF1YWxzJzogW3sgUmVmOiAnQVdTOjpSZWdpb24nIH0sIHJpLm5hbWVdIH0pKSk7XG59XG5cbi8qKlxuICogVGhpcyB0YWtlcyBhIGJ1bmNoIG9mIG9wZXJhbmRzIGFuZCBjcmFmdHMgYW4gYEZuOjpPcmAgZm9yIHRob3NlLiBGdW5ueSB0aGluZyBpcyBgRm46Ok9yYCByZXF1aXJlc1xuICogYXQgbGVhc3QgMiBvcGVyYW5kcyBhbmQgYXQgbW9zdCAxMCBvcGVyYW5kcywgc28gd2UgaGF2ZSB0by4uLiBkbyB0aGlzLlxuICovXG5mdW5jdGlvbiBfZm5PcihvcGVyYW5kczogYW55W10pOiBhbnkge1xuICBpZiAob3BlcmFuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYnVpbGQgYEZuOjpPcmAgd2l0aCB6ZXJvIG9wZXJhbmRzIScpO1xuICB9XG4gIGlmIChvcGVyYW5kcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gb3BlcmFuZHNbMF07XG4gIH1cbiAgaWYgKG9wZXJhbmRzLmxlbmd0aCA8PSAxMCkge1xuICAgIHJldHVybiB7ICdGbjo6T3InOiBvcGVyYW5kcyB9O1xuICB9XG4gIHJldHVybiBfZm5PcihfaW5Hcm91cHNPZihvcGVyYW5kcywgMTApLm1hcChncm91cCA9PiBfZm5Pcihncm91cCkpKTtcbn1cblxuZnVuY3Rpb24gX2luR3JvdXBzT2Y8VD4oYXJyYXk6IFRbXSwgbWF4R3JvdXA6IG51bWJlcik6IFRbXVtdIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PFRbXT4oKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gbWF4R3JvdXApIHtcbiAgICByZXN1bHQucHVzaChhcnJheS5zbGljZShpLCBpICsgbWF4R3JvdXApKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNb2R1bGVzKHJ1bnRpbWU6IGN4YXBpLlJ1bnRpbWVJbmZvKTogc3RyaW5nIHtcbiAgY29uc3QgbW9kdWxlcyA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgLy8gaW5qZWN0IHRvb2xraXQgdmVyc2lvbiB0byBsaXN0IG9mIG1vZHVsZXNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgY29uc3QgdG9vbGtpdFZlcnNpb24gPSByZXF1aXJlKCcuLi8uLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuICBtb2R1bGVzLnB1c2goYGF3cy1jZGs9JHt0b29sa2l0VmVyc2lvbn1gKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhydW50aW1lLmxpYnJhcmllcykuc29ydCgpKSB7XG4gICAgbW9kdWxlcy5wdXNoKGAke2tleX09JHtydW50aW1lLmxpYnJhcmllc1trZXldfWApO1xuICB9XG4gIHJldHVybiBtb2R1bGVzLmpvaW4oJywnKTtcbn1cbiJdfQ==