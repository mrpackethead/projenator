"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableLambdaFunctionChange = void 0;
const common_1 = require("./common");
/**
 * Returns `false` if the change cannot be short-circuited,
 * `true` if the change is irrelevant from a short-circuit perspective
 * (like a change to CDKMetadata),
 * or a LambdaFunctionResource if the change can be short-circuited.
 */
async function isHotswappableLambdaFunctionChange(logicalId, change, evaluateCfnTemplate) {
    var _a;
    const lambdaCodeChange = await isLambdaFunctionCodeOnlyChange(change, evaluateCfnTemplate);
    if (typeof lambdaCodeChange === 'string') {
        return lambdaCodeChange;
    }
    else {
        // verify that the Asset changed - otherwise,
        // it's a Code property-only change,
        // but not to an asset change
        // (for example, going from Code.fromAsset() to Code.fromInline())
        if (!common_1.assetMetadataChanged(change)) {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
        const functionName = await common_1.establishResourcePhysicalName(logicalId, (_a = change.newValue.Properties) === null || _a === void 0 ? void 0 : _a.FunctionName, evaluateCfnTemplate);
        if (!functionName) {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
        return new LambdaFunctionHotswapOperation({
            physicalName: functionName,
            code: lambdaCodeChange,
        });
    }
}
exports.isHotswappableLambdaFunctionChange = isHotswappableLambdaFunctionChange;
/**
 * Returns `ChangeHotswapImpact.IRRELEVANT` if the change is not for a AWS::Lambda::Function,
 * but doesn't prevent short-circuiting
 * (like a change to CDKMetadata resource),
 * `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` if the change is to a AWS::Lambda::Function,
 * but not only to its Code property,
 * or a LambdaFunctionCode if the change is to a AWS::Lambda::Function,
 * and only affects its Code property.
 */
async function isLambdaFunctionCodeOnlyChange(change, evaluateCfnTemplate) {
    const newResourceType = change.newValue.Type;
    if (newResourceType !== 'AWS::Lambda::Function') {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    /*
     * On first glance, we would want to initialize these using the "previous" values (change.oldValue),
     * in case only one of them changed, like the key, and the Bucket stayed the same.
     * However, that actually fails for old-style synthesis, which uses CFN Parameters!
     * Because the names of the Parameters depend on the hash of the Asset,
     * the Parameters used for the "old" values no longer exist in `assetParams` at this point,
     * which means we don't have the correct values available to evaluate the CFN expression with.
     * Fortunately, the diff will always include both the s3Bucket and s3Key parts of the Lambda's Code property,
     * even if only one of them was actually changed,
     * which means we don't need the "old" values at all, and we can safely initialize these with just `''`.
     */
    let s3Bucket = '', s3Key = '';
    let foundCodeDifference = false;
    // Make sure only the code in the Lambda function changed
    const propertyUpdates = change.propertyUpdates;
    for (const updatedPropName in propertyUpdates) {
        const updatedProp = propertyUpdates[updatedPropName];
        for (const newPropName in updatedProp.newValue) {
            switch (newPropName) {
                case 'S3Bucket':
                    foundCodeDifference = true;
                    s3Bucket = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                    break;
                case 'S3Key':
                    foundCodeDifference = true;
                    s3Key = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                    break;
                default:
                    return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
            }
        }
    }
    return foundCodeDifference
        ? {
            s3Bucket,
            s3Key,
        }
        : common_1.ChangeHotswapImpact.IRRELEVANT;
}
class LambdaFunctionHotswapOperation {
    constructor(lambdaFunctionResource) {
        this.lambdaFunctionResource = lambdaFunctionResource;
        this.service = 'lambda-function';
    }
    async apply(sdk) {
        return sdk.lambda().updateFunctionCode({
            FunctionName: this.lambdaFunctionResource.physicalName,
            S3Bucket: this.lambdaFunctionResource.code.s3Bucket,
            S3Key: this.lambdaFunctionResource.code.s3Key,
        }).promise();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhLWZ1bmN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxhbWJkYS1mdW5jdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EscUNBQXdLO0FBR3hLOzs7OztHQUtHO0FBQ0ksS0FBSyxVQUFVLGtDQUFrQyxDQUN0RCxTQUFpQixFQUFFLE1BQW1DLEVBQUUsbUJBQW1EOztJQUUzRyxNQUFNLGdCQUFnQixHQUFHLE1BQU0sOEJBQThCLENBQUMsTUFBTSxFQUFFLG1CQUFtQixDQUFDLENBQUM7SUFDM0YsSUFBSSxPQUFPLGdCQUFnQixLQUFLLFFBQVEsRUFBRTtRQUN4QyxPQUFPLGdCQUFnQixDQUFDO0tBQ3pCO1NBQU07UUFDTCw2Q0FBNkM7UUFDN0Msb0NBQW9DO1FBQ3BDLDZCQUE2QjtRQUM3QixrRUFBa0U7UUFDbEUsSUFBSSxDQUFDLDZCQUFvQixDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2pDLE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7U0FDckQ7UUFFRCxNQUFNLFlBQVksR0FBRyxNQUFNLHNDQUE2QixDQUFDLFNBQVMsUUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLFVBQVUsMENBQUUsWUFBWSxFQUFFLG1CQUFtQixDQUFDLENBQUM7UUFDbkksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNqQixPQUFPLDRCQUFtQixDQUFDLHdCQUF3QixDQUFDO1NBQ3JEO1FBRUQsT0FBTyxJQUFJLDhCQUE4QixDQUFDO1lBQ3hDLFlBQVksRUFBRSxZQUFZO1lBQzFCLElBQUksRUFBRSxnQkFBZ0I7U0FDdkIsQ0FBQyxDQUFDO0tBQ0o7QUFDSCxDQUFDO0FBekJELGdGQXlCQztBQUVEOzs7Ozs7OztHQVFHO0FBQ0gsS0FBSyxVQUFVLDhCQUE4QixDQUMzQyxNQUFtQyxFQUFFLG1CQUFtRDtJQUV4RixNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztJQUM3QyxJQUFJLGVBQWUsS0FBSyx1QkFBdUIsRUFBRTtRQUMvQyxPQUFPLDRCQUFtQixDQUFDLHdCQUF3QixDQUFDO0tBQ3JEO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILElBQUksUUFBUSxHQUFHLEVBQUUsRUFBRSxLQUFLLEdBQUcsRUFBRSxDQUFDO0lBQzlCLElBQUksbUJBQW1CLEdBQUcsS0FBSyxDQUFDO0lBQ2hDLHlEQUF5RDtJQUN6RCxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsZUFBZSxDQUFDO0lBQy9DLEtBQUssTUFBTSxlQUFlLElBQUksZUFBZSxFQUFFO1FBQzdDLE1BQU0sV0FBVyxHQUFHLGVBQWUsQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUNyRCxLQUFLLE1BQU0sV0FBVyxJQUFJLFdBQVcsQ0FBQyxRQUFRLEVBQUU7WUFDOUMsUUFBUSxXQUFXLEVBQUU7Z0JBQ25CLEtBQUssVUFBVTtvQkFDYixtQkFBbUIsR0FBRyxJQUFJLENBQUM7b0JBQzNCLFFBQVEsR0FBRyxNQUFNLG1CQUFtQixDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztvQkFDOUYsTUFBTTtnQkFDUixLQUFLLE9BQU87b0JBQ1YsbUJBQW1CLEdBQUcsSUFBSSxDQUFDO29CQUMzQixLQUFLLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7b0JBQzNGLE1BQU07Z0JBQ1I7b0JBQ0UsT0FBTyw0QkFBbUIsQ0FBQyx3QkFBd0IsQ0FBQzthQUN2RDtTQUNGO0tBQ0Y7SUFFRCxPQUFPLG1CQUFtQjtRQUN4QixDQUFDLENBQUM7WUFDQSxRQUFRO1lBQ1IsS0FBSztTQUNOO1FBQ0QsQ0FBQyxDQUFDLDRCQUFtQixDQUFDLFVBQVUsQ0FBQztBQUNyQyxDQUFDO0FBWUQsTUFBTSw4QkFBOEI7SUFHbEMsWUFBNkIsc0JBQThDO1FBQTlDLDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBd0I7UUFGM0QsWUFBTyxHQUFHLGlCQUFpQixDQUFDO0lBRzVDLENBQUM7SUFFTSxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQVM7UUFDMUIsT0FBTyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsa0JBQWtCLENBQUM7WUFDckMsWUFBWSxFQUFFLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxZQUFZO1lBQ3RELFFBQVEsRUFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLFFBQVE7WUFDbkQsS0FBSyxFQUFFLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsS0FBSztTQUM5QyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDZixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJU0RLIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgYXNzZXRNZXRhZGF0YUNoYW5nZWQsIENoYW5nZUhvdHN3YXBJbXBhY3QsIENoYW5nZUhvdHN3YXBSZXN1bHQsIEhvdHN3YXBPcGVyYXRpb24sIEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgZXN0YWJsaXNoUmVzb3VyY2VQaHlzaWNhbE5hbWUgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUgfSBmcm9tICcuL2V2YWx1YXRlLWNsb3VkZm9ybWF0aW9uLXRlbXBsYXRlJztcblxuLyoqXG4gKiBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIGNoYW5nZSBjYW5ub3QgYmUgc2hvcnQtY2lyY3VpdGVkLFxuICogYHRydWVgIGlmIHRoZSBjaGFuZ2UgaXMgaXJyZWxldmFudCBmcm9tIGEgc2hvcnQtY2lyY3VpdCBwZXJzcGVjdGl2ZVxuICogKGxpa2UgYSBjaGFuZ2UgdG8gQ0RLTWV0YWRhdGEpLFxuICogb3IgYSBMYW1iZGFGdW5jdGlvblJlc291cmNlIGlmIHRoZSBjaGFuZ2UgY2FuIGJlIHNob3J0LWNpcmN1aXRlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzSG90c3dhcHBhYmxlTGFtYmRhRnVuY3Rpb25DaGFuZ2UoXG4gIGxvZ2ljYWxJZDogc3RyaW5nLCBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuKTogUHJvbWlzZTxDaGFuZ2VIb3Rzd2FwUmVzdWx0PiB7XG4gIGNvbnN0IGxhbWJkYUNvZGVDaGFuZ2UgPSBhd2FpdCBpc0xhbWJkYUZ1bmN0aW9uQ29kZU9ubHlDaGFuZ2UoY2hhbmdlLCBldmFsdWF0ZUNmblRlbXBsYXRlKTtcbiAgaWYgKHR5cGVvZiBsYW1iZGFDb2RlQ2hhbmdlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBsYW1iZGFDb2RlQ2hhbmdlO1xuICB9IGVsc2Uge1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoZSBBc3NldCBjaGFuZ2VkIC0gb3RoZXJ3aXNlLFxuICAgIC8vIGl0J3MgYSBDb2RlIHByb3BlcnR5LW9ubHkgY2hhbmdlLFxuICAgIC8vIGJ1dCBub3QgdG8gYW4gYXNzZXQgY2hhbmdlXG4gICAgLy8gKGZvciBleGFtcGxlLCBnb2luZyBmcm9tIENvZGUuZnJvbUFzc2V0KCkgdG8gQ29kZS5mcm9tSW5saW5lKCkpXG4gICAgaWYgKCFhc3NldE1ldGFkYXRhQ2hhbmdlZChjaGFuZ2UpKSB7XG4gICAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gICAgfVxuXG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYXdhaXQgZXN0YWJsaXNoUmVzb3VyY2VQaHlzaWNhbE5hbWUobG9naWNhbElkLCBjaGFuZ2UubmV3VmFsdWUuUHJvcGVydGllcz8uRnVuY3Rpb25OYW1lLCBldmFsdWF0ZUNmblRlbXBsYXRlKTtcbiAgICBpZiAoIWZ1bmN0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTGFtYmRhRnVuY3Rpb25Ib3Rzd2FwT3BlcmF0aW9uKHtcbiAgICAgIHBoeXNpY2FsTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgY29kZTogbGFtYmRhQ29kZUNoYW5nZSxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYENoYW5nZUhvdHN3YXBJbXBhY3QuSVJSRUxFVkFOVGAgaWYgdGhlIGNoYW5nZSBpcyBub3QgZm9yIGEgQVdTOjpMYW1iZGE6OkZ1bmN0aW9uLFxuICogYnV0IGRvZXNuJ3QgcHJldmVudCBzaG9ydC1jaXJjdWl0aW5nXG4gKiAobGlrZSBhIGNoYW5nZSB0byBDREtNZXRhZGF0YSByZXNvdXJjZSksXG4gKiBgQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlRgIGlmIHRoZSBjaGFuZ2UgaXMgdG8gYSBBV1M6OkxhbWJkYTo6RnVuY3Rpb24sXG4gKiBidXQgbm90IG9ubHkgdG8gaXRzIENvZGUgcHJvcGVydHksXG4gKiBvciBhIExhbWJkYUZ1bmN0aW9uQ29kZSBpZiB0aGUgY2hhbmdlIGlzIHRvIGEgQVdTOjpMYW1iZGE6OkZ1bmN0aW9uLFxuICogYW5kIG9ubHkgYWZmZWN0cyBpdHMgQ29kZSBwcm9wZXJ0eS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaXNMYW1iZGFGdW5jdGlvbkNvZGVPbmx5Q2hhbmdlKFxuICBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuKTogUHJvbWlzZTxMYW1iZGFGdW5jdGlvbkNvZGUgfCBDaGFuZ2VIb3Rzd2FwSW1wYWN0PiB7XG4gIGNvbnN0IG5ld1Jlc291cmNlVHlwZSA9IGNoYW5nZS5uZXdWYWx1ZS5UeXBlO1xuICBpZiAobmV3UmVzb3VyY2VUeXBlICE9PSAnQVdTOjpMYW1iZGE6OkZ1bmN0aW9uJykge1xuICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgfVxuXG4gIC8qXG4gICAqIE9uIGZpcnN0IGdsYW5jZSwgd2Ugd291bGQgd2FudCB0byBpbml0aWFsaXplIHRoZXNlIHVzaW5nIHRoZSBcInByZXZpb3VzXCIgdmFsdWVzIChjaGFuZ2Uub2xkVmFsdWUpLFxuICAgKiBpbiBjYXNlIG9ubHkgb25lIG9mIHRoZW0gY2hhbmdlZCwgbGlrZSB0aGUga2V5LCBhbmQgdGhlIEJ1Y2tldCBzdGF5ZWQgdGhlIHNhbWUuXG4gICAqIEhvd2V2ZXIsIHRoYXQgYWN0dWFsbHkgZmFpbHMgZm9yIG9sZC1zdHlsZSBzeW50aGVzaXMsIHdoaWNoIHVzZXMgQ0ZOIFBhcmFtZXRlcnMhXG4gICAqIEJlY2F1c2UgdGhlIG5hbWVzIG9mIHRoZSBQYXJhbWV0ZXJzIGRlcGVuZCBvbiB0aGUgaGFzaCBvZiB0aGUgQXNzZXQsXG4gICAqIHRoZSBQYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBcIm9sZFwiIHZhbHVlcyBubyBsb25nZXIgZXhpc3QgaW4gYGFzc2V0UGFyYW1zYCBhdCB0aGlzIHBvaW50LFxuICAgKiB3aGljaCBtZWFucyB3ZSBkb24ndCBoYXZlIHRoZSBjb3JyZWN0IHZhbHVlcyBhdmFpbGFibGUgdG8gZXZhbHVhdGUgdGhlIENGTiBleHByZXNzaW9uIHdpdGguXG4gICAqIEZvcnR1bmF0ZWx5LCB0aGUgZGlmZiB3aWxsIGFsd2F5cyBpbmNsdWRlIGJvdGggdGhlIHMzQnVja2V0IGFuZCBzM0tleSBwYXJ0cyBvZiB0aGUgTGFtYmRhJ3MgQ29kZSBwcm9wZXJ0eSxcbiAgICogZXZlbiBpZiBvbmx5IG9uZSBvZiB0aGVtIHdhcyBhY3R1YWxseSBjaGFuZ2VkLFxuICAgKiB3aGljaCBtZWFucyB3ZSBkb24ndCBuZWVkIHRoZSBcIm9sZFwiIHZhbHVlcyBhdCBhbGwsIGFuZCB3ZSBjYW4gc2FmZWx5IGluaXRpYWxpemUgdGhlc2Ugd2l0aCBqdXN0IGAnJ2AuXG4gICAqL1xuICBsZXQgczNCdWNrZXQgPSAnJywgczNLZXkgPSAnJztcbiAgbGV0IGZvdW5kQ29kZURpZmZlcmVuY2UgPSBmYWxzZTtcbiAgLy8gTWFrZSBzdXJlIG9ubHkgdGhlIGNvZGUgaW4gdGhlIExhbWJkYSBmdW5jdGlvbiBjaGFuZ2VkXG4gIGNvbnN0IHByb3BlcnR5VXBkYXRlcyA9IGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXM7XG4gIGZvciAoY29uc3QgdXBkYXRlZFByb3BOYW1lIGluIHByb3BlcnR5VXBkYXRlcykge1xuICAgIGNvbnN0IHVwZGF0ZWRQcm9wID0gcHJvcGVydHlVcGRhdGVzW3VwZGF0ZWRQcm9wTmFtZV07XG4gICAgZm9yIChjb25zdCBuZXdQcm9wTmFtZSBpbiB1cGRhdGVkUHJvcC5uZXdWYWx1ZSkge1xuICAgICAgc3dpdGNoIChuZXdQcm9wTmFtZSkge1xuICAgICAgICBjYXNlICdTM0J1Y2tldCc6XG4gICAgICAgICAgZm91bmRDb2RlRGlmZmVyZW5jZSA9IHRydWU7XG4gICAgICAgICAgczNCdWNrZXQgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih1cGRhdGVkUHJvcC5uZXdWYWx1ZVtuZXdQcm9wTmFtZV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTM0tleSc6XG4gICAgICAgICAgZm91bmRDb2RlRGlmZmVyZW5jZSA9IHRydWU7XG4gICAgICAgICAgczNLZXkgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih1cGRhdGVkUHJvcC5uZXdWYWx1ZVtuZXdQcm9wTmFtZV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm91bmRDb2RlRGlmZmVyZW5jZVxuICAgID8ge1xuICAgICAgczNCdWNrZXQsXG4gICAgICBzM0tleSxcbiAgICB9XG4gICAgOiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LklSUkVMRVZBTlQ7XG59XG5cbmludGVyZmFjZSBMYW1iZGFGdW5jdGlvbkNvZGUge1xuICByZWFkb25seSBzM0J1Y2tldDogc3RyaW5nO1xuICByZWFkb25seSBzM0tleTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgTGFtYmRhRnVuY3Rpb25SZXNvdXJjZSB7XG4gIHJlYWRvbmx5IHBoeXNpY2FsTmFtZTogc3RyaW5nO1xuICByZWFkb25seSBjb2RlOiBMYW1iZGFGdW5jdGlvbkNvZGU7XG59XG5cbmNsYXNzIExhbWJkYUZ1bmN0aW9uSG90c3dhcE9wZXJhdGlvbiBpbXBsZW1lbnRzIEhvdHN3YXBPcGVyYXRpb24ge1xuICBwdWJsaWMgcmVhZG9ubHkgc2VydmljZSA9ICdsYW1iZGEtZnVuY3Rpb24nO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgbGFtYmRhRnVuY3Rpb25SZXNvdXJjZTogTGFtYmRhRnVuY3Rpb25SZXNvdXJjZSkge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGFwcGx5KHNkazogSVNESyk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHNkay5sYW1iZGEoKS51cGRhdGVGdW5jdGlvbkNvZGUoe1xuICAgICAgRnVuY3Rpb25OYW1lOiB0aGlzLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UucGh5c2ljYWxOYW1lLFxuICAgICAgUzNCdWNrZXQ6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5jb2RlLnMzQnVja2V0LFxuICAgICAgUzNLZXk6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5jb2RlLnMzS2V5LFxuICAgIH0pLnByb21pc2UoKTtcbiAgfVxufVxuIl19