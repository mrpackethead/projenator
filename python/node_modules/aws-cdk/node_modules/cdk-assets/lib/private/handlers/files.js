"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileAssetHandler = void 0;
const fs_1 = require("fs");
const path = require("path");
const cloud_assembly_schema_1 = require("@aws-cdk/cloud-assembly-schema");
const mime = require("mime");
const progress_1 = require("../../progress");
const archive_1 = require("../archive");
const fs_extra_1 = require("../fs-extra");
const placeholders_1 = require("../placeholders");
const shell_1 = require("../shell");
class FileAssetHandler {
    constructor(workDir, asset, host) {
        this.workDir = workDir;
        this.asset = asset;
        this.host = host;
        this.fileCacheRoot = path.join(workDir, '.cache');
    }
    async publish() {
        const destination = await placeholders_1.replaceAwsPlaceholders(this.asset.destination, this.host.aws);
        const s3Url = `s3://${destination.bucketName}/${destination.objectKey}`;
        const s3 = await this.host.aws.s3Client(destination);
        this.host.emitMessage(progress_1.EventType.CHECK, `Check ${s3Url}`);
        const bucketInfo = BucketInformation.for(this.host);
        // A thunk for describing the current account. Used when we need to format an error
        // message, not in the success case.
        const account = async () => { var _a; return (_a = (await this.host.aws.discoverCurrentAccount())) === null || _a === void 0 ? void 0 : _a.accountId; };
        switch (await bucketInfo.bucketOwnership(s3, destination.bucketName)) {
            case BucketOwnership.MINE:
                break;
            case BucketOwnership.DOES_NOT_EXIST:
                throw new Error(`No bucket named '${destination.bucketName}'. Is account ${await account()} bootstrapped?`);
            case BucketOwnership.SOMEONE_ELSES_OR_NO_ACCESS:
                throw new Error(`Bucket named '${destination.bucketName}' exists, but not in account ${await account()}. Wrong account?`);
        }
        if (await objectExists(s3, destination.bucketName, destination.objectKey)) {
            this.host.emitMessage(progress_1.EventType.FOUND, `Found ${s3Url}`);
            return;
        }
        // Identify the the bucket encryption type to set the header on upload
        // required for SCP rules denying uploads without encryption header
        let paramsEncryption = {};
        const encryption2 = await bucketInfo.bucketEncryption(s3, destination.bucketName);
        switch (encryption2) {
            case BucketEncryption.NO_ENCRYPTION:
                break;
            case BucketEncryption.SSEAlgorithm_AES256:
                paramsEncryption = { ServerSideEncryption: 'AES256' };
                break;
            case BucketEncryption.SSEAlgorithm_aws_kms:
                paramsEncryption = { ServerSideEncryption: 'aws:kms' };
                break;
            case BucketEncryption.DOES_NOT_EXIST:
                this.host.emitMessage(progress_1.EventType.DEBUG, `No bucket named '${destination.bucketName}'. Is account ${await account()} bootstrapped?`);
                break;
            case BucketEncryption.ACCES_DENIED:
                this.host.emitMessage(progress_1.EventType.DEBUG, `ACCES_DENIED for getting encryption of bucket '${destination.bucketName}'. Either wrong account ${await account()} or s3:GetEncryptionConfiguration not set for cdk role. Try "cdk bootstrap" again.`);
                break;
        }
        if (this.host.aborted) {
            return;
        }
        const publishFile = this.asset.source.executable ?
            await this.externalPackageFile(this.asset.source.executable) : await this.packageFile(this.asset.source);
        this.host.emitMessage(progress_1.EventType.UPLOAD, `Upload ${s3Url}`);
        const params = Object.assign({}, {
            Bucket: destination.bucketName,
            Key: destination.objectKey,
            Body: fs_1.createReadStream(publishFile.packagedPath),
            ContentType: publishFile.contentType,
        }, paramsEncryption);
        await s3.upload(params).promise();
    }
    async packageFile(source) {
        var _a;
        if (!source.path) {
            throw new Error(`'path' is expected in the File asset source, got: ${JSON.stringify(source)}`);
        }
        const fullPath = path.resolve(this.workDir, source.path);
        if (source.packaging === cloud_assembly_schema_1.FileAssetPackaging.ZIP_DIRECTORY) {
            const contentType = 'application/zip';
            await fs_1.promises.mkdir(this.fileCacheRoot, { recursive: true });
            const packagedPath = path.join(this.fileCacheRoot, `${this.asset.id.assetId}.zip`);
            if (await fs_extra_1.pathExists(packagedPath)) {
                this.host.emitMessage(progress_1.EventType.CACHED, `From cache ${path}`);
                return { packagedPath, contentType };
            }
            this.host.emitMessage(progress_1.EventType.BUILD, `Zip ${fullPath} -> ${path}`);
            await archive_1.zipDirectory(fullPath, packagedPath);
            return { packagedPath, contentType };
        }
        else {
            const contentType = (_a = mime.getType(fullPath)) !== null && _a !== void 0 ? _a : 'application/octet-stream';
            return { packagedPath: fullPath, contentType };
        }
    }
    async externalPackageFile(executable) {
        this.host.emitMessage(progress_1.EventType.BUILD, `Building asset source using command: '${executable}'`);
        return {
            packagedPath: (await shell_1.shell(executable, { quiet: true })).trim(),
            contentType: 'application/zip',
        };
    }
}
exports.FileAssetHandler = FileAssetHandler;
var BucketOwnership;
(function (BucketOwnership) {
    BucketOwnership[BucketOwnership["DOES_NOT_EXIST"] = 0] = "DOES_NOT_EXIST";
    BucketOwnership[BucketOwnership["MINE"] = 1] = "MINE";
    BucketOwnership[BucketOwnership["SOMEONE_ELSES_OR_NO_ACCESS"] = 2] = "SOMEONE_ELSES_OR_NO_ACCESS";
})(BucketOwnership || (BucketOwnership = {}));
var BucketEncryption;
(function (BucketEncryption) {
    BucketEncryption[BucketEncryption["NO_ENCRYPTION"] = 0] = "NO_ENCRYPTION";
    BucketEncryption[BucketEncryption["SSEAlgorithm_AES256"] = 1] = "SSEAlgorithm_AES256";
    BucketEncryption[BucketEncryption["SSEAlgorithm_aws_kms"] = 2] = "SSEAlgorithm_aws_kms";
    BucketEncryption[BucketEncryption["ACCES_DENIED"] = 3] = "ACCES_DENIED";
    BucketEncryption[BucketEncryption["DOES_NOT_EXIST"] = 4] = "DOES_NOT_EXIST";
})(BucketEncryption || (BucketEncryption = {}));
async function objectExists(s3, bucket, key) {
    /*
     * The object existence check here refrains from using the `headObject` operation because this
     * would create a negative cache entry, making GET-after-PUT eventually consistent. This has been
     * observed to result in CloudFormation issuing "ValidationError: S3 error: Access Denied", for
     * example in https://github.com/aws/aws-cdk/issues/6430.
     *
     * To prevent this, we are instead using the listObjectsV2 call, using the looked up key as the
     * prefix, and limiting results to 1. Since the list operation returns keys ordered by binary
     * UTF-8 representation, the key we are looking for is guaranteed to always be the first match
     * returned if it exists.
     */
    const response = await s3.listObjectsV2({ Bucket: bucket, Prefix: key, MaxKeys: 1 }).promise();
    return response.Contents != null && response.Contents.some(object => object.Key === key);
}
/**
 * Cache for bucket information, so we don't have to keep doing the same calls again and again
 *
 * We scope the lifetime of the cache to the lifetime of the host, so that we don't have to do
 * anything special for tests and yet the cache will live for the entire lifetime of the asset
 * upload session when used by the CLI.
 */
class BucketInformation {
    constructor() {
        this.ownerships = new Map();
        this.encryptions = new Map();
    }
    static for(host) {
        const existing = BucketInformation.caches.get(host);
        if (existing) {
            return existing;
        }
        const fresh = new BucketInformation();
        BucketInformation.caches.set(host, fresh);
        return fresh;
    }
    async bucketOwnership(s3, bucket) {
        return cached(this.ownerships, bucket, () => this._bucketOwnership(s3, bucket));
    }
    async bucketEncryption(s3, bucket) {
        return cached(this.encryptions, bucket, () => this._bucketEncryption(s3, bucket));
    }
    async _bucketOwnership(s3, bucket) {
        try {
            await s3.getBucketLocation({ Bucket: bucket }).promise();
            return BucketOwnership.MINE;
        }
        catch (e) {
            if (e.code === 'NoSuchBucket') {
                return BucketOwnership.DOES_NOT_EXIST;
            }
            if (['AccessDenied', 'AllAccessDisabled'].includes(e.code)) {
                return BucketOwnership.SOMEONE_ELSES_OR_NO_ACCESS;
            }
            throw e;
        }
    }
    async _bucketEncryption(s3, bucket) {
        var _a, _b, _c, _d, _e, _f;
        try {
            const encryption = await s3.getBucketEncryption({ Bucket: bucket }).promise();
            const l = (_c = (_b = (_a = encryption === null || encryption === void 0 ? void 0 : encryption.ServerSideEncryptionConfiguration) === null || _a === void 0 ? void 0 : _a.Rules) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
            if (l > 0) {
                let ssealgo = (_f = (_e = (_d = encryption === null || encryption === void 0 ? void 0 : encryption.ServerSideEncryptionConfiguration) === null || _d === void 0 ? void 0 : _d.Rules[0]) === null || _e === void 0 ? void 0 : _e.ApplyServerSideEncryptionByDefault) === null || _f === void 0 ? void 0 : _f.SSEAlgorithm;
                if (ssealgo === 'AES256')
                    return BucketEncryption.SSEAlgorithm_AES256;
                if (ssealgo === 'aws:kms')
                    return BucketEncryption.SSEAlgorithm_aws_kms;
            }
            return BucketEncryption.NO_ENCRYPTION;
        }
        catch (e) {
            if (e.code === 'NoSuchBucket') {
                return BucketEncryption.DOES_NOT_EXIST;
            }
            if (e.code === 'ServerSideEncryptionConfigurationNotFoundError') {
                return BucketEncryption.NO_ENCRYPTION;
            }
            if (['AccessDenied', 'AllAccessDisabled'].includes(e.code)) {
                return BucketEncryption.ACCES_DENIED;
            }
            return BucketEncryption.NO_ENCRYPTION;
        }
    }
}
BucketInformation.caches = new WeakMap();
async function cached(cache, key, factory) {
    if (cache.has(key)) {
        return cache.get(key);
    }
    const fresh = await factory(key);
    cache.set(key, fresh);
    return fresh;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmaWxlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwyQkFBc0Q7QUFDdEQsNkJBQTZCO0FBQzdCLDBFQUFnRjtBQUNoRiw2QkFBNkI7QUFFN0IsNkNBQTJDO0FBQzNDLHdDQUEwQztBQUUxQywwQ0FBeUM7QUFDekMsa0RBQXlEO0FBQ3pELG9DQUFpQztBQUVqQyxNQUFhLGdCQUFnQjtJQUczQixZQUNtQixPQUFlLEVBQ2YsS0FBd0IsRUFDeEIsSUFBa0I7UUFGbEIsWUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUNmLFVBQUssR0FBTCxLQUFLLENBQW1CO1FBQ3hCLFNBQUksR0FBSixJQUFJLENBQWM7UUFDbkMsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU87UUFDbEIsTUFBTSxXQUFXLEdBQUcsTUFBTSxxQ0FBc0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hGLE1BQU0sS0FBSyxHQUFHLFFBQVEsV0FBVyxDQUFDLFVBQVUsSUFBSSxXQUFXLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDeEUsTUFBTSxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDckQsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsb0JBQVMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBRXpELE1BQU0sVUFBVSxHQUFHLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFcEQsbUZBQW1GO1FBQ25GLG9DQUFvQztRQUNwQyxNQUFNLE9BQU8sR0FB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b3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVSZWFkU3RyZWFtLCBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBGaWxlQXNzZXRQYWNrYWdpbmcsIEZpbGVTb3VyY2UgfSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgbWltZSBmcm9tICdtaW1lJztcbmltcG9ydCB7IEZpbGVNYW5pZmVzdEVudHJ5IH0gZnJvbSAnLi4vLi4vYXNzZXQtbWFuaWZlc3QnO1xuaW1wb3J0IHsgRXZlbnRUeXBlIH0gZnJvbSAnLi4vLi4vcHJvZ3Jlc3MnO1xuaW1wb3J0IHsgemlwRGlyZWN0b3J5IH0gZnJvbSAnLi4vYXJjaGl2ZSc7XG5pbXBvcnQgeyBJQXNzZXRIYW5kbGVyLCBJSGFuZGxlckhvc3QgfSBmcm9tICcuLi9hc3NldC1oYW5kbGVyJztcbmltcG9ydCB7IHBhdGhFeGlzdHMgfSBmcm9tICcuLi9mcy1leHRyYSc7XG5pbXBvcnQgeyByZXBsYWNlQXdzUGxhY2Vob2xkZXJzIH0gZnJvbSAnLi4vcGxhY2Vob2xkZXJzJztcbmltcG9ydCB7IHNoZWxsIH0gZnJvbSAnLi4vc2hlbGwnO1xuXG5leHBvcnQgY2xhc3MgRmlsZUFzc2V0SGFuZGxlciBpbXBsZW1lbnRzIElBc3NldEhhbmRsZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGZpbGVDYWNoZVJvb3Q6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHdvcmtEaXI6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFzc2V0OiBGaWxlTWFuaWZlc3RFbnRyeSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGhvc3Q6IElIYW5kbGVySG9zdCkge1xuICAgIHRoaXMuZmlsZUNhY2hlUm9vdCA9IHBhdGguam9pbih3b3JrRGlyLCAnLmNhY2hlJyk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcHVibGlzaCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IGF3YWl0IHJlcGxhY2VBd3NQbGFjZWhvbGRlcnModGhpcy5hc3NldC5kZXN0aW5hdGlvbiwgdGhpcy5ob3N0LmF3cyk7XG4gICAgY29uc3QgczNVcmwgPSBgczM6Ly8ke2Rlc3RpbmF0aW9uLmJ1Y2tldE5hbWV9LyR7ZGVzdGluYXRpb24ub2JqZWN0S2V5fWA7XG4gICAgY29uc3QgczMgPSBhd2FpdCB0aGlzLmhvc3QuYXdzLnMzQ2xpZW50KGRlc3RpbmF0aW9uKTtcbiAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkNIRUNLLCBgQ2hlY2sgJHtzM1VybH1gKTtcblxuICAgIGNvbnN0IGJ1Y2tldEluZm8gPSBCdWNrZXRJbmZvcm1hdGlvbi5mb3IodGhpcy5ob3N0KTtcblxuICAgIC8vIEEgdGh1bmsgZm9yIGRlc2NyaWJpbmcgdGhlIGN1cnJlbnQgYWNjb3VudC4gVXNlZCB3aGVuIHdlIG5lZWQgdG8gZm9ybWF0IGFuIGVycm9yXG4gICAgLy8gbWVzc2FnZSwgbm90IGluIHRoZSBzdWNjZXNzIGNhc2UuXG4gICAgY29uc3QgYWNjb3VudCA9IGFzeW5jICgpID0+IChhd2FpdCB0aGlzLmhvc3QuYXdzLmRpc2NvdmVyQ3VycmVudEFjY291bnQoKSk/LmFjY291bnRJZDtcbiAgICBzd2l0Y2ggKGF3YWl0IGJ1Y2tldEluZm8uYnVja2V0T3duZXJzaGlwKHMzLCBkZXN0aW5hdGlvbi5idWNrZXROYW1lKSkge1xuICAgICAgY2FzZSBCdWNrZXRPd25lcnNoaXAuTUlORTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJ1Y2tldE93bmVyc2hpcC5ET0VTX05PVF9FWElTVDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBidWNrZXQgbmFtZWQgJyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0nLiBJcyBhY2NvdW50ICR7YXdhaXQgYWNjb3VudCgpfSBib290c3RyYXBwZWQ/YCk7XG4gICAgICBjYXNlIEJ1Y2tldE93bmVyc2hpcC5TT01FT05FX0VMU0VTX09SX05PX0FDQ0VTUzpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCdWNrZXQgbmFtZWQgJyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0nIGV4aXN0cywgYnV0IG5vdCBpbiBhY2NvdW50ICR7YXdhaXQgYWNjb3VudCgpfS4gV3JvbmcgYWNjb3VudD9gKTtcbiAgICB9XG5cbiAgICBpZiAoYXdhaXQgb2JqZWN0RXhpc3RzKHMzLCBkZXN0aW5hdGlvbi5idWNrZXROYW1lLCBkZXN0aW5hdGlvbi5vYmplY3RLZXkpKSB7XG4gICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkZPVU5ELCBgRm91bmQgJHtzM1VybH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZGVudGlmeSB0aGUgdGhlIGJ1Y2tldCBlbmNyeXB0aW9uIHR5cGUgdG8gc2V0IHRoZSBoZWFkZXIgb24gdXBsb2FkXG4gICAgLy8gcmVxdWlyZWQgZm9yIFNDUCBydWxlcyBkZW55aW5nIHVwbG9hZHMgd2l0aG91dCBlbmNyeXB0aW9uIGhlYWRlclxuICAgIGxldCBwYXJhbXNFbmNyeXB0aW9uOiB7W2luZGV4OiBzdHJpbmddOmFueX09IHt9O1xuICAgIGNvbnN0IGVuY3J5cHRpb24yID0gYXdhaXQgYnVja2V0SW5mby5idWNrZXRFbmNyeXB0aW9uKHMzLCBkZXN0aW5hdGlvbi5idWNrZXROYW1lKTtcbiAgICBzd2l0Y2ggKGVuY3J5cHRpb24yKSB7XG4gICAgICBjYXNlIEJ1Y2tldEVuY3J5cHRpb24uTk9fRU5DUllQVElPTjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJ1Y2tldEVuY3J5cHRpb24uU1NFQWxnb3JpdGhtX0FFUzI1NjpcbiAgICAgICAgcGFyYW1zRW5jcnlwdGlvbiA9IHsgU2VydmVyU2lkZUVuY3J5cHRpb246ICdBRVMyNTYnIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCdWNrZXRFbmNyeXB0aW9uLlNTRUFsZ29yaXRobV9hd3Nfa21zOlxuICAgICAgICBwYXJhbXNFbmNyeXB0aW9uID0geyBTZXJ2ZXJTaWRlRW5jcnlwdGlvbjogJ2F3czprbXMnIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCdWNrZXRFbmNyeXB0aW9uLkRPRVNfTk9UX0VYSVNUOlxuICAgICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkRFQlVHLCBgTm8gYnVja2V0IG5hbWVkICcke2Rlc3RpbmF0aW9uLmJ1Y2tldE5hbWV9Jy4gSXMgYWNjb3VudCAke2F3YWl0IGFjY291bnQoKX0gYm9vdHN0cmFwcGVkP2ApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQnVja2V0RW5jcnlwdGlvbi5BQ0NFU19ERU5JRUQ6XG4gICAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuREVCVUcsIGBBQ0NFU19ERU5JRUQgZm9yIGdldHRpbmcgZW5jcnlwdGlvbiBvZiBidWNrZXQgJyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0nLiBFaXRoZXIgd3JvbmcgYWNjb3VudCAke2F3YWl0IGFjY291bnQoKX0gb3IgczM6R2V0RW5jcnlwdGlvbkNvbmZpZ3VyYXRpb24gbm90IHNldCBmb3IgY2RrIHJvbGUuIFRyeSBcImNkayBib290c3RyYXBcIiBhZ2Fpbi5gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdC5hYm9ydGVkKSB7IHJldHVybjsgfVxuICAgIGNvbnN0IHB1Ymxpc2hGaWxlID0gdGhpcy5hc3NldC5zb3VyY2UuZXhlY3V0YWJsZSA/XG4gICAgICBhd2FpdCB0aGlzLmV4dGVybmFsUGFja2FnZUZpbGUodGhpcy5hc3NldC5zb3VyY2UuZXhlY3V0YWJsZSkgOiBhd2FpdCB0aGlzLnBhY2thZ2VGaWxlKHRoaXMuYXNzZXQuc291cmNlKTtcblxuICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuVVBMT0FELCBgVXBsb2FkICR7czNVcmx9YCk7XG5cbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICBCdWNrZXQ6IGRlc3RpbmF0aW9uLmJ1Y2tldE5hbWUsXG4gICAgICBLZXk6IGRlc3RpbmF0aW9uLm9iamVjdEtleSxcbiAgICAgIEJvZHk6IGNyZWF0ZVJlYWRTdHJlYW0ocHVibGlzaEZpbGUucGFja2FnZWRQYXRoKSxcbiAgICAgIENvbnRlbnRUeXBlOiBwdWJsaXNoRmlsZS5jb250ZW50VHlwZSxcbiAgICB9LFxuICAgIHBhcmFtc0VuY3J5cHRpb24pO1xuXG4gICAgYXdhaXQgczMudXBsb2FkKHBhcmFtcykucHJvbWlzZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBwYWNrYWdlRmlsZShzb3VyY2U6IEZpbGVTb3VyY2UpOiBQcm9taXNlPFBhY2thZ2VkRmlsZUFzc2V0PiB7XG4gICAgaWYgKCFzb3VyY2UucGF0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAncGF0aCcgaXMgZXhwZWN0ZWQgaW4gdGhlIEZpbGUgYXNzZXQgc291cmNlLCBnb3Q6ICR7SlNPTi5zdHJpbmdpZnkoc291cmNlKX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLndvcmtEaXIsIHNvdXJjZS5wYXRoKTtcblxuICAgIGlmIChzb3VyY2UucGFja2FnaW5nID09PSBGaWxlQXNzZXRQYWNrYWdpbmcuWklQX0RJUkVDVE9SWSkge1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24vemlwJztcblxuICAgICAgYXdhaXQgZnMubWtkaXIodGhpcy5maWxlQ2FjaGVSb290LCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IHBhY2thZ2VkUGF0aCA9IHBhdGguam9pbih0aGlzLmZpbGVDYWNoZVJvb3QsIGAke3RoaXMuYXNzZXQuaWQuYXNzZXRJZH0uemlwYCk7XG5cbiAgICAgIGlmIChhd2FpdCBwYXRoRXhpc3RzKHBhY2thZ2VkUGF0aCkpIHtcbiAgICAgICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5DQUNIRUQsIGBGcm9tIGNhY2hlICR7cGF0aH1gKTtcbiAgICAgICAgcmV0dXJuIHsgcGFja2FnZWRQYXRoLCBjb250ZW50VHlwZSB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkJVSUxELCBgWmlwICR7ZnVsbFBhdGh9IC0+ICR7cGF0aH1gKTtcbiAgICAgIGF3YWl0IHppcERpcmVjdG9yeShmdWxsUGF0aCwgcGFja2FnZWRQYXRoKTtcbiAgICAgIHJldHVybiB7IHBhY2thZ2VkUGF0aCwgY29udGVudFR5cGUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSBtaW1lLmdldFR5cGUoZnVsbFBhdGgpID8/ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgcmV0dXJuIHsgcGFja2FnZWRQYXRoOiBmdWxsUGF0aCwgY29udGVudFR5cGUgfTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGV4dGVybmFsUGFja2FnZUZpbGUoZXhlY3V0YWJsZTogc3RyaW5nW10pOiBQcm9taXNlPFBhY2thZ2VkRmlsZUFzc2V0PiB7XG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5CVUlMRCwgYEJ1aWxkaW5nIGFzc2V0IHNvdXJjZSB1c2luZyBjb21tYW5kOiAnJHtleGVjdXRhYmxlfSdgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYWNrYWdlZFBhdGg6IChhd2FpdCBzaGVsbChleGVjdXRhYmxlLCB7IHF1aWV0OiB0cnVlIH0pKS50cmltKCksXG4gICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL3ppcCcsXG4gICAgfTtcbiAgfVxufVxuXG5lbnVtIEJ1Y2tldE93bmVyc2hpcCB7XG4gIERPRVNfTk9UX0VYSVNULFxuICBNSU5FLFxuICBTT01FT05FX0VMU0VTX09SX05PX0FDQ0VTU1xufVxuXG5lbnVtIEJ1Y2tldEVuY3J5cHRpb24ge1xuICBOT19FTkNSWVBUSU9OLFxuICBTU0VBbGdvcml0aG1fQUVTMjU2LFxuICBTU0VBbGdvcml0aG1fYXdzX2ttcyxcbiAgQUNDRVNfREVOSUVELFxuICBET0VTX05PVF9FWElTVFxufVxuXG5hc3luYyBmdW5jdGlvbiBvYmplY3RFeGlzdHMoczM6IEFXUy5TMywgYnVja2V0OiBzdHJpbmcsIGtleTogc3RyaW5nKSB7XG4gIC8qXG4gICAqIFRoZSBvYmplY3QgZXhpc3RlbmNlIGNoZWNrIGhlcmUgcmVmcmFpbnMgZnJvbSB1c2luZyB0aGUgYGhlYWRPYmplY3RgIG9wZXJhdGlvbiBiZWNhdXNlIHRoaXNcbiAgICogd291bGQgY3JlYXRlIGEgbmVnYXRpdmUgY2FjaGUgZW50cnksIG1ha2luZyBHRVQtYWZ0ZXItUFVUIGV2ZW50dWFsbHkgY29uc2lzdGVudC4gVGhpcyBoYXMgYmVlblxuICAgKiBvYnNlcnZlZCB0byByZXN1bHQgaW4gQ2xvdWRGb3JtYXRpb24gaXNzdWluZyBcIlZhbGlkYXRpb25FcnJvcjogUzMgZXJyb3I6IEFjY2VzcyBEZW5pZWRcIiwgZm9yXG4gICAqIGV4YW1wbGUgaW4gaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy82NDMwLlxuICAgKlxuICAgKiBUbyBwcmV2ZW50IHRoaXMsIHdlIGFyZSBpbnN0ZWFkIHVzaW5nIHRoZSBsaXN0T2JqZWN0c1YyIGNhbGwsIHVzaW5nIHRoZSBsb29rZWQgdXAga2V5IGFzIHRoZVxuICAgKiBwcmVmaXgsIGFuZCBsaW1pdGluZyByZXN1bHRzIHRvIDEuIFNpbmNlIHRoZSBsaXN0IG9wZXJhdGlvbiByZXR1cm5zIGtleXMgb3JkZXJlZCBieSBiaW5hcnlcbiAgICogVVRGLTggcmVwcmVzZW50YXRpb24sIHRoZSBrZXkgd2UgYXJlIGxvb2tpbmcgZm9yIGlzIGd1YXJhbnRlZWQgdG8gYWx3YXlzIGJlIHRoZSBmaXJzdCBtYXRjaFxuICAgKiByZXR1cm5lZCBpZiBpdCBleGlzdHMuXG4gICAqL1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHMzLmxpc3RPYmplY3RzVjIoeyBCdWNrZXQ6IGJ1Y2tldCwgUHJlZml4OiBrZXksIE1heEtleXM6IDEgfSkucHJvbWlzZSgpO1xuICByZXR1cm4gcmVzcG9uc2UuQ29udGVudHMgIT0gbnVsbCAmJiByZXNwb25zZS5Db250ZW50cy5zb21lKG9iamVjdCA9PiBvYmplY3QuS2V5ID09PSBrZXkpO1xufVxuXG5cbi8qKlxuICogQSBwYWNrYWdlZCBhc3NldCB3aGljaCBjYW4gYmUgdXBsb2FkZWQgKGVpdGhlciBhIHNpbmdsZSBmaWxlIG9yIGRpcmVjdG9yeSlcbiAqL1xuaW50ZXJmYWNlIFBhY2thZ2VkRmlsZUFzc2V0IHtcbiAgLyoqXG4gICAqIFBhdGggb2YgdGhlIGZpbGUgb3IgZGlyZWN0b3J5XG4gICAqL1xuICByZWFkb25seSBwYWNrYWdlZFBhdGg6IHN0cmluZztcblxuICAvKipcbiAgICogQ29udGVudCB0eXBlIHRvIGJlIGFkZGVkIGluIHRoZSBTMyB1cGxvYWQgYWN0aW9uXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gY29udGVudCB0eXBlXG4gICAqL1xuICByZWFkb25seSBjb250ZW50VHlwZT86IHN0cmluZztcbn1cblxuXG4vKipcbiAqIENhY2hlIGZvciBidWNrZXQgaW5mb3JtYXRpb24sIHNvIHdlIGRvbid0IGhhdmUgdG8ga2VlcCBkb2luZyB0aGUgc2FtZSBjYWxscyBhZ2FpbiBhbmQgYWdhaW5cbiAqXG4gKiBXZSBzY29wZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGNhY2hlIHRvIHRoZSBsaWZldGltZSBvZiB0aGUgaG9zdCwgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGRvXG4gKiBhbnl0aGluZyBzcGVjaWFsIGZvciB0ZXN0cyBhbmQgeWV0IHRoZSBjYWNoZSB3aWxsIGxpdmUgZm9yIHRoZSBlbnRpcmUgbGlmZXRpbWUgb2YgdGhlIGFzc2V0XG4gKiB1cGxvYWQgc2Vzc2lvbiB3aGVuIHVzZWQgYnkgdGhlIENMSS5cbiAqL1xuY2xhc3MgQnVja2V0SW5mb3JtYXRpb24ge1xuICBwdWJsaWMgc3RhdGljIGZvcihob3N0OiBJSGFuZGxlckhvc3QpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IEJ1Y2tldEluZm9ybWF0aW9uLmNhY2hlcy5nZXQoaG9zdCk7XG4gICAgaWYgKGV4aXN0aW5nKSB7IHJldHVybiBleGlzdGluZzsgfVxuXG4gICAgY29uc3QgZnJlc2ggPSBuZXcgQnVja2V0SW5mb3JtYXRpb24oKTtcbiAgICBCdWNrZXRJbmZvcm1hdGlvbi5jYWNoZXMuc2V0KGhvc3QsIGZyZXNoKTtcbiAgICByZXR1cm4gZnJlc2g7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBjYWNoZXMgPSBuZXcgV2Vha01hcDxJSGFuZGxlckhvc3QsIEJ1Y2tldEluZm9ybWF0aW9uPigpO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgb3duZXJzaGlwcyA9IG5ldyBNYXA8c3RyaW5nLCBCdWNrZXRPd25lcnNoaXA+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgZW5jcnlwdGlvbnMgPSBuZXcgTWFwPHN0cmluZywgQnVja2V0RW5jcnlwdGlvbj4oKTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGJ1Y2tldE93bmVyc2hpcChzMzogQVdTLlMzLCBidWNrZXQ6IHN0cmluZyk6IFByb21pc2U8QnVja2V0T3duZXJzaGlwPiB7XG4gICAgcmV0dXJuIGNhY2hlZCh0aGlzLm93bmVyc2hpcHMsIGJ1Y2tldCwgKCkgPT4gdGhpcy5fYnVja2V0T3duZXJzaGlwKHMzLCBidWNrZXQpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBidWNrZXRFbmNyeXB0aW9uKHMzOiBBV1MuUzMsIGJ1Y2tldDogc3RyaW5nKTogUHJvbWlzZTxCdWNrZXRFbmNyeXB0aW9uPiB7XG4gICAgcmV0dXJuIGNhY2hlZCh0aGlzLmVuY3J5cHRpb25zLCBidWNrZXQsICgpID0+IHRoaXMuX2J1Y2tldEVuY3J5cHRpb24oczMsIGJ1Y2tldCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfYnVja2V0T3duZXJzaGlwKHMzOiBBV1MuUzMsIGJ1Y2tldDogc3RyaW5nKTogUHJvbWlzZTxCdWNrZXRPd25lcnNoaXA+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgczMuZ2V0QnVja2V0TG9jYXRpb24oeyBCdWNrZXQ6IGJ1Y2tldCB9KS5wcm9taXNlKCk7XG4gICAgICByZXR1cm4gQnVja2V0T3duZXJzaGlwLk1JTkU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuY29kZSA9PT0gJ05vU3VjaEJ1Y2tldCcpIHsgcmV0dXJuIEJ1Y2tldE93bmVyc2hpcC5ET0VTX05PVF9FWElTVDsgfVxuICAgICAgaWYgKFsnQWNjZXNzRGVuaWVkJywgJ0FsbEFjY2Vzc0Rpc2FibGVkJ10uaW5jbHVkZXMoZS5jb2RlKSkgeyByZXR1cm4gQnVja2V0T3duZXJzaGlwLlNPTUVPTkVfRUxTRVNfT1JfTk9fQUNDRVNTOyB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2J1Y2tldEVuY3J5cHRpb24oczM6IEFXUy5TMywgYnVja2V0OiBzdHJpbmcpOiBQcm9taXNlPEJ1Y2tldEVuY3J5cHRpb24+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW5jcnlwdGlvbiA9IGF3YWl0IHMzLmdldEJ1Y2tldEVuY3J5cHRpb24oeyBCdWNrZXQ6IGJ1Y2tldCB9KS5wcm9taXNlKCk7XG4gICAgICBjb25zdCBsID0gZW5jcnlwdGlvbj8uU2VydmVyU2lkZUVuY3J5cHRpb25Db25maWd1cmF0aW9uPy5SdWxlcz8ubGVuZ3RoID8/IDA7XG4gICAgICBpZiAobCA+IDApIHtcbiAgICAgICAgbGV0IHNzZWFsZ28gPSBlbmNyeXB0aW9uPy5TZXJ2ZXJTaWRlRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb24/LlJ1bGVzWzBdPy5BcHBseVNlcnZlclNpZGVFbmNyeXB0aW9uQnlEZWZhdWx0Py5TU0VBbGdvcml0aG07XG4gICAgICAgIGlmIChzc2VhbGdvID09PSAnQUVTMjU2JykgcmV0dXJuIEJ1Y2tldEVuY3J5cHRpb24uU1NFQWxnb3JpdGhtX0FFUzI1NjtcbiAgICAgICAgaWYgKHNzZWFsZ28gPT09ICdhd3M6a21zJykgcmV0dXJuIEJ1Y2tldEVuY3J5cHRpb24uU1NFQWxnb3JpdGhtX2F3c19rbXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gQnVja2V0RW5jcnlwdGlvbi5OT19FTkNSWVBUSU9OO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmNvZGUgPT09ICdOb1N1Y2hCdWNrZXQnKSB7XG4gICAgICAgIHJldHVybiBCdWNrZXRFbmNyeXB0aW9uLkRPRVNfTk9UX0VYSVNUO1xuICAgICAgfVxuICAgICAgaWYgKGUuY29kZSA9PT0gJ1NlcnZlclNpZGVFbmNyeXB0aW9uQ29uZmlndXJhdGlvbk5vdEZvdW5kRXJyb3InKSB7XG4gICAgICAgIHJldHVybiBCdWNrZXRFbmNyeXB0aW9uLk5PX0VOQ1JZUFRJT047XG4gICAgICB9XG5cbiAgICAgIGlmIChbJ0FjY2Vzc0RlbmllZCcsICdBbGxBY2Nlc3NEaXNhYmxlZCddLmluY2x1ZGVzKGUuY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIEJ1Y2tldEVuY3J5cHRpb24uQUNDRVNfREVOSUVEO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJ1Y2tldEVuY3J5cHRpb24uTk9fRU5DUllQVElPTjtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FjaGVkPEEsIEI+KGNhY2hlOiBNYXA8QSwgQj4sIGtleTogQSwgZmFjdG9yeTogKHg6IEEpID0+IFByb21pc2U8Qj4pOiBQcm9taXNlPEI+IHtcbiAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldChrZXkpITtcbiAgfVxuXG4gIGNvbnN0IGZyZXNoID0gYXdhaXQgZmFjdG9yeShrZXkpO1xuICBjYWNoZS5zZXQoa2V5LCBmcmVzaCk7XG4gIHJldHVybiBmcmVzaDtcbn0iXX0=